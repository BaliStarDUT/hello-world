我来为您按时间复杂度分类各种排序算法：
## 排序算法时间复杂度分类
### 一、O(n²) 时间复杂度 - 简单排序算法

| 算法名称 | 时间复杂度(平均) | 空间复杂度 | 稳定性 | 特点 |
|---------|------------------|------------|--------|------|
| **选择排序** | O(n²) | O(1) | 不稳定 | 每次选择最小/最大元素 |
| **冒泡排序** | O(n²) | O(1) | 稳定 | 相邻元素交换，像气泡上浮 |
| **插入排序** | O(n²) | O(1) | 稳定 | 构建有序序列，插入新元素 |
**选择排序**（您代码中的算法）：
- 每次从未排序部分选择最小元素
- 交换次数较少（最多n-1次）
- 但比较次数固定为n(n-1)/2次
### 二、O(n log n) 时间复杂度 - 高效排序算法
| 算法名称 | 时间复杂度(平均) | 空间复杂度 | 稳定性 | 特点 |
|---------|------------------|------------|--------|------|
| **快速排序** | O(n log n) | O(log n) | 不稳定 | 分治法，选基准元素分区 |
| **归并排序** | O(n log n) | O(n) | 稳定 | 分治法，合并有序子序列 |
| **堆排序** | O(n log n) | O(1) | 不稳定 | 利用堆数据结构 |
**快速排序**特点：
- 平均性能最好，实际应用最广泛
- 最坏情况O(n²)（但概率极低）
- 原地排序，空间效率高
### 三、O(n) 时间复杂度 - 特殊场景算法
| 算法名称 | 时间复杂度 | 空间复杂度 | 适用场景 |
|---------|------------|------------|----------|
| **计数排序** | O(n+k) | O(k) | 整数排序，范围k不大 |
| **桶排序** | O(n+k) | O(n+k) | 均匀分布的浮点数 |
| **基数排序** | O(d×(n+k)) | O(n+k) | 整数或字符串，d为位数 |
### 四、各算法性能对比图
```
时间复杂度对比：
O(n²): 选择、冒泡、插入
   ↓
O(n log n): 快速、归并、堆
   ↓
O(n): 计数、桶、基数（特定条件）
数据规模影响：
- 小规模（n < 50）：插入排序
- 中规模（50 ≤ n ≤ 1000）：快速排序
- 大规模（n > 1000）：归并排序或快速排序
- 特殊数据：计数/桶/基数排序
```
### 五、实际应用建议
1. **小规模数据**：插入排序（简单且对小数据高效）
2. **一般情况**：快速排序（平均性能最佳）
3. **需要稳定性**：归并排序
4. **内存受限**：堆排序
5. **整数且范围小**：计数排序
6. **浮点数均匀分布**：桶排序
您的选择排序代码虽然时间复杂度为O(n²)，但在以下场景仍有价值：
- 教学演示（算法思路清晰）
- 小规模数据排序
- 交换操作成本高但比较成本低的情况","reasoning_content":"","tool_call_info":{"id":"68b6d7901eca3e71c44155f4","name":"response_to_user","params":{"summary":"我来为您按时间复杂度分类各种排序算法：
## 排序算法时间复杂度分类
### 一、O(n²) 时间复杂度 - 简单排序算法
| 算法名称 | 时间复杂度(平均) | 空间复杂度 | 稳定性 | 特点 |
|---------|------------------|------------|--------|------|
| **选择排序** | O(n²) | O(1) | 不稳定 | 每次选择最小/最大元素 |
| **冒泡排序** | O(n²) | O(1) | 稳定 | 相邻元素交换，像气泡上浮 |
| **插入排序** | O(n²) | O(1) | 稳定 | 构建有序序列，插入新元素 |
**选择排序**（您代码中的算法）：
- 每次从未排序部分选择最小元素
- 交换次数较少（最多n-1次）
- 但比较次数固定为n(n-1)/2次
### 二、O(n log n) 时间复杂度 - 高效排序算法
| 算法名称 | 时间复杂度(平均) | 空间复杂度 | 稳定性 | 特点 |
|---------|------------------|------------|--------|------|
| **快速排序** | O(n log n) | O(log n) | 不稳定 | 分治法，选基准元素分区 |
| **归并排序** | O(n log n) | O(n) | 稳定 | 分治法，合并有序子序列 |
| **堆排序** | O(n log n) | O(1) | 不稳定 | 利用堆数据结构 |
**快速排序**特点：
- 平均性能最好，实际应用最广泛
- 最坏情况O(n²)（但概率极低）
- 原地排序，空间效率高
### 三、O(n) 时间复杂度 - 特殊场景算法
| 算法名称 | 时间复杂度 | 空间复杂度 | 适用场景 |
|---------|------------|------------|----------|
| **计数排序** | O(n+k) | O(k) | 整数排序，范围k不大 |
| **桶排序** | O(n+k) | O(n+k) | 均匀分布的浮点数 |
| **基数排序** | O(d×(n+k)) | O(n+k) | 整数或字符串，d为位数 |
### 四、各算法性能对比图
```
时间复杂度对比：
O(n²): 选择、冒泡、插入
   ↓
O(n log n): 快速、归并、堆
   ↓
O(n): 计数、桶、基数（特定条件）
数据规模影响：
- 小规模（n < 50）：插入排序
- 中规模（50 ≤ n ≤ 1000）：快速排序
- 大规模（n > 1000）：归并排序或快速排序
- 特殊数据：计数/桶/基数排序
```
### 五、实际应用建议
1. **小规模数据**：插入排序（简单且对小数据高效）
2. **一般情况**：快速排序（平均性能最佳）
3. **需要稳定性**：归并排序
4. **内存受限**：堆排序
5. **整数且范围小**：计数排序
6. **浮点数均匀分布**：桶排序
您的选择排序代码虽然时间复杂度为O(n²)，但在以下场景仍有价值：
- 教学演示（算法思路清晰）
- 小规模数据排序
- 交换操作成本高但比较成本低的情况"},"result":{"status":"success","error_message":"","data":{"summary":"我来为您按时间复杂度分类各种排序算法：
## 排序算法时间复杂度分类
### 一、O(n²) 时间复杂度 - 简单排序算法
| 算法名称 | 时间复杂度(平均) | 空间复杂度 | 稳定性 | 特点 |
|---------|------------------|------------|--------|------|
| **选择排序** | O(n²) | O(1) | 不稳定 | 每次选择最小/最大元素 |
| **冒泡排序** | O(n²) | O(1) | 稳定 | 相邻元素交换，像气泡上浮 |
| **插入排序** | O(n²) | O(1) | 稳定 | 构建有序序列，插入新元素 |
**选择排序**（您代码中的算法）：
- 每次从未排序部分选择最小元素
- 交换次数较少（最多n-1次）
- 但比较次数固定为n(n-1)/2次
### 二、O(n log n) 时间复杂度 - 高效排序算法
| 算法名称 | 时间复杂度(平均) | 空间复杂度 | 稳定性 | 特点 |
|---------|------------------|------------|--------|------|
| **快速排序** | O(n log n) | O(log n) | 不稳定 | 分治法，选基准元素分区 |
| **归并排序** | O(n log n) | O(n) | 稳定 | 分治法，合并有序子序列 |
| **堆排序** | O(n log n) | O(1) | 不稳定 | 利用堆数据结构 |
**快速排序**特点：
- 平均性能最好，实际应用最广泛
- 最坏情况O(n²)（但概率极低）
- 原地排序，空间效率高
### 三、O(n) 时间复杂度 - 特殊场景算法
| 算法名称 | 时间复杂度 | 空间复杂度 | 适用场景 |
|---------|------------|------------|----------|
| **计数排序** | O(n+k) | O(k) | 整数排序，范围k不大 |
| **桶排序** | O(n+k) | O(n+k) | 均匀分布的浮点数 |
| **基数排序** | O(d×(n+k)) | O(n+k) | 整数或字符串，d为位数 |
### 四、各算法性能对比图
```
时间复杂度对比：
O(n²): 选择、冒泡、插入
   ↓
O(n log n): 快速、归并、堆
   ↓
O(n): 计数、桶、基数（特定条件）
数据规模影响：
- 小规模（n < 50）：插入排序
- 中规模（50 ≤ n ≤ 1000）：快速排序
- 大规模（n > 1000）：归并排序或快速排序
- 特殊数据：计数/桶/基数排序
```
### 五、实际应用建议
1. **小规模数据**：插入排序（简单且对小数据高效）
2. **一般情况**：快速排序（平均性能最佳）
3. **需要稳定性**：归并排序
4. **内存受限**：堆排序
5. **整数且范围小**：计数排序
6. **浮点数均匀分布**：桶排序
您的选择排序代码虽然时间复杂度为O(n²)，但在以下场景仍有价值：
- 教学演示（算法思路清晰）
- 小规模数据排序
- 交换操作成本高但比较成本低的情况